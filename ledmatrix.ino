// ----------------------------------------------------------------------------
//   ledmatrix.ino
// ----------------------------------------------------------------------------

// first version: summer 2008
//
// this release:
// - compiled with arduino 1.8.5
// - hardware used: arduino diecimila

// --- configuration and system defaults --------------------------------------

#define REP 123  // frame repetitions
#define PAU 27   // inter-scanline pause

bool reverse = true;  // if true, orientation is towards usb plug


// --- font -------------------------------------------------------------------

const unsigned char font[] PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //  32 (0x20): " "
   0x00, 0x00, 0xfa, 0x00, 0x00, 0x00,  //  33 (0x21): "!"
   0x00, 0xe0, 0x00, 0xe0, 0x00, 0x00,  //  34 (0x22): '"'
   0x28, 0xfe, 0x28, 0xfe, 0x28, 0x00,  //  35 (0x23): "#"
   0x20, 0x54, 0xfe, 0x54, 0x08, 0x00,  //  36 (0x24): "$"
   0x46, 0xa8, 0x54, 0x2a, 0xc4, 0x00,  //  37 (0x25): "%"
   0x6c, 0x92, 0x6a, 0x04, 0x0a, 0x00,  //  38 (0x26): "&"
   0x00, 0x00, 0xe0, 0x00, 0x00, 0x00,  //  39 (0x27): "'"
   0x00, 0x38, 0x44, 0x82, 0x00, 0x00,  //  40 (0x28): "("
   0x00, 0x82, 0x44, 0x38, 0x00, 0x00,  //  41 (0x29): ")"
   0x54, 0x38, 0x7c, 0x38, 0x54, 0x00,  //  42 (0x2a): "*"
   0x10, 0x10, 0x7c, 0x10, 0x10, 0x00,  //  43 (0x2b): "+"
   0x00, 0x01, 0x06, 0x04, 0x00, 0x00,  //  44 (0x2c): ","
   0x10, 0x10, 0x10, 0x10, 0x10, 0x00,  //  45 (0x2d): "-"
   0x00, 0x02, 0x07, 0x02, 0x00, 0x00,  //  46 (0x2e): "."
   0x06, 0x08, 0x10, 0x20, 0xc0, 0x00,  //  47 (0x2f): "/"
   0x7c, 0x8a, 0x92, 0xa2, 0x7c, 0x00,  //  48 (0x30): "0"
   0x22, 0x42, 0xfe, 0x02, 0x02, 0x00,  //  49 (0x31): "1"
   0x46, 0x8a, 0x92, 0x92, 0x62, 0x00,  //  50 (0x32): "2"
   0x44, 0x82, 0x92, 0x92, 0x6c, 0x00,  //  51 (0x33): "3"
   0x18, 0x28, 0x48, 0xfe, 0x08, 0x00,  //  52 (0x34): "4"
   0xe4, 0xa2, 0xa2, 0xa2, 0x9c, 0x00,  //  53 (0x35): "5"
   0x7c, 0x92, 0x92, 0x92, 0x4c, 0x00,  //  54 (0x36): "6"
   0x80, 0x86, 0x88, 0xb0, 0xc0, 0x00,  //  55 (0x37): "7"
   0x6c, 0x92, 0x92, 0x92, 0x6c, 0x00,  //  56 (0x38): "8"
   0x64, 0x92, 0x92, 0x92, 0x7c, 0x00,  //  57 (0x39): "9"
   0x00, 0x22, 0x77, 0x22, 0x00, 0x00,  //  58 (0x3a): ":"
   0x00, 0x21, 0x76, 0x24, 0x00, 0x00,  //  59 (0x3b): ";"
   0x00, 0x10, 0x28, 0x44, 0x82, 0x00,  //  60 (0x3c): "<"
   0x28, 0x28, 0x28, 0x28, 0x28, 0x00,  //  61 (0x3d): "="
   0x00, 0x82, 0x44, 0x28, 0x10, 0x00,  //  62 (0x3e): ">"
   0x40, 0x80, 0x9a, 0xa0, 0x40, 0x00,  //  63 (0x3f): "?"
   0x7c, 0x82, 0x9a, 0xaa, 0x70, 0x00,  //  64 (0x40): "@"
   0x3e, 0x48, 0x88, 0x48, 0x3e, 0x00,  //  65 (0x41): "A"
   0x82, 0xfe, 0x92, 0x92, 0x6c, 0x00,  //  66 (0x42): "B"
   0x7c, 0x82, 0x82, 0x82, 0x44, 0x00,  //  67 (0x43): "C"
   0x82, 0xfe, 0x82, 0x82, 0x7c, 0x00,  //  68 (0x44): "D"
   0xfe, 0x92, 0x92, 0x92, 0x82, 0x00,  //  69 (0x45): "E"
   0xfe, 0x90, 0x90, 0x90, 0x80, 0x00,  //  70 (0x46): "F"
   0x7c, 0x82, 0x82, 0x8a, 0x4c, 0x00,  //  71 (0x47): "G"
   0xfe, 0x10, 0x10, 0x10, 0xfe, 0x00,  //  72 (0x48): "H"
   0x00, 0x82, 0xfe, 0x82, 0x00, 0x00,  //  73 (0x49): "I"
   0x04, 0x02, 0x82, 0xfc, 0x80, 0x00,  //  74 (0x4a): "J"
   0xfe, 0x10, 0x28, 0x44, 0x82, 0x00,  //  75 (0x4b): "K"
   0xfe, 0x02, 0x02, 0x02, 0x02, 0x00,  //  76 (0x4c): "L"
   0xfe, 0x20, 0x10, 0x20, 0xfe, 0x00,  //  77 (0x4d): "M"
   0xfe, 0x20, 0x10, 0x08, 0xfe, 0x00,  //  78 (0x4e): "N"
   0x7c, 0x82, 0x82, 0x82, 0x7c, 0x00,  //  79 (0x4f): "O"
   0xfe, 0x90, 0x90, 0x90, 0x60, 0x00,  //  80 (0x50): "P"
   0x7c, 0x82, 0x86, 0x82, 0x7d, 0x00,  //  81 (0x51): "Q"
   0xfe, 0x90, 0x98, 0x94, 0x62, 0x00,  //  82 (0x52): "R"
   0x64, 0x92, 0x92, 0x92, 0x4c, 0x00,  //  83 (0x53): "S"
   0x80, 0x80, 0xfe, 0x80, 0x80, 0x00,  //  84 (0x54): "T"
   0xfc, 0x02, 0x02, 0x02, 0xfc, 0x00,  //  85 (0x55): "U"
   0xe0, 0x1c, 0x02, 0x1c, 0xe0, 0x00,  //  86 (0x56): "V"
   0xfe, 0x04, 0x18, 0x04, 0xfe, 0x00,  //  87 (0x57): "W"
   0xc6, 0x28, 0x10, 0x28, 0xc6, 0x00,  //  88 (0x58): "X"
   0xc0, 0x20, 0x1e, 0x20, 0xc0, 0x00,  //  89 (0x59): "Y"
   0x86, 0x8a, 0x92, 0xa2, 0xc2, 0x00,  //  90 (0x5a): "Z"
   0x00, 0xfe, 0x82, 0x82, 0x00, 0x00,  //  91 (0x5b): "["
   0xc0, 0x20, 0x10, 0x08, 0x06, 0x00,  //  92 (0x5c): backslash
   0x00, 0x82, 0x82, 0xfe, 0x00, 0x00,  //  93 (0x5d): "]"
   0x20, 0x40, 0x80, 0x40, 0x20, 0x00,  //  94 (0x5e): accent
   0x01, 0x01, 0x01, 0x01, 0x01, 0x00,  //  95 (0x5f): "_"
   0x00, 0x00, 0x80, 0x40, 0x00, 0x00,  //  96 (0x60): backquote
   0x04, 0x2a, 0x2a, 0x2a, 0x1e, 0x00,  //  97 (0x61): "a"
   0xfe, 0x14, 0x22, 0x22, 0x1c, 0x00,  //  98 (0x62): "b"
   0x1c, 0x22, 0x22, 0x22, 0x14, 0x00,  //  99 (0x63): "c"
   0x1c, 0x22, 0x22, 0x14, 0xfe, 0x00,  // 100 (0x64): "d"
   0x1c, 0x2a, 0x2a, 0x2a, 0x18, 0x00,  // 101 (0x65): "e"
   0x10, 0x7e, 0x90, 0x90, 0x40, 0x00,  // 102 (0x66): "f"
   0x19, 0x25, 0x25, 0x25, 0x3e, 0x00,  // 103 (0x67): "g"
   0xfe, 0x10, 0x20, 0x20, 0x1e, 0x00,  // 104 (0x68): "h"
   0x02, 0x22, 0xbe, 0x02, 0x02, 0x00,  // 105 (0x69): "i"
   0x00, 0x02, 0x01, 0x21, 0xbe, 0x00,  // 106 (0x6a): "j"
   0xfe, 0x08, 0x08, 0x14, 0x22, 0x00,  // 107 (0x6b): "k"
   0x00, 0x82, 0xfe, 0x02, 0x00, 0x00,  // 108 (0x6c): "l"
   0x3e, 0x20, 0x1c, 0x20, 0x1e, 0x00,  // 109 (0x6d): "m"
   0x3e, 0x10, 0x20, 0x20, 0x1e, 0x00,  // 110 (0x6e): "n"
   0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00,  // 111 (0x6f): "o"
   0x3f, 0x14, 0x22, 0x22, 0x1c, 0x00,  // 112 (0x70): "p"
   0x1c, 0x22, 0x22, 0x14, 0x3f, 0x00,  // 113 (0x71): "q"
   0x3e, 0x10, 0x20, 0x20, 0x10, 0x00,  // 114 (0x72): "r"
   0x12, 0x2a, 0x2a, 0x2a, 0x04, 0x00,  // 115 (0x73): "s"
   0x20, 0xfc, 0x22, 0x22, 0x04, 0x00,  // 116 (0x74): "t"
   0x3c, 0x02, 0x02, 0x04, 0x3e, 0x00,  // 117 (0x75): "u"
   0x30, 0x0c, 0x02, 0x0c, 0x30, 0x00,  // 118 (0x76): "v"
   0x3c, 0x02, 0x0c, 0x02, 0x3c, 0x00,  // 119 (0x77): "w"
   0x22, 0x14, 0x08, 0x14, 0x22, 0x00,  // 120 (0x78): "x"
   0x39, 0x05, 0x05, 0x05, 0x3e, 0x00,  // 121 (0x79): "y"
   0x22, 0x26, 0x2a, 0x32, 0x22, 0x00,  // 122 (0x7a): "z"
   0x10, 0x54, 0xaa, 0x82, 0x00, 0x00,  // 123 (0x7b): "{"
   0x00, 0xfe, 0x00, 0x00, 0x00, 0x00,  // 124 (0x7c): "|"
   0x82, 0xaa, 0x54, 0x10, 0x00, 0x60,  // 125 (0x7d): "}"
   0x40, 0x80, 0x80, 0x40, 0x40, 0x80,  // 126 (0x7e): "~"
   0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,  // 127 (0x7f): grid
   0x04, 0x2a, 0xaa, 0x6a, 0x1e, 0x00,  // 128 (0x80): "à"
   0x1c, 0x2a, 0xaa, 0x6a, 0x18, 0x00,  // 129 (0x81): "è"
   0x1c, 0x2a, 0x6a, 0xaa, 0x18, 0x00,  // 130 (0x82): "é"
   0x02, 0x22, 0xbe, 0x82, 0x02, 0x00,  // 131 (0x83): "ì"
   0x1c, 0x22, 0x22, 0xa2, 0x5c, 0x00,  // 132 (0x84): "ò"
   0x3c, 0x02, 0x02, 0x84, 0x7e, 0x00,  // 133 (0x85): "ù"
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  // 134 (0x86): black square
   0x3c, 0x24, 0x24, 0x24, 0x24, 0x3c,  // 135 (0x87): small empty square
   0x7e, 0x42, 0x42, 0x42, 0x42, 0x7e,  // 136 (0x88): empty square
   0xff, 0x81, 0x81, 0x81, 0x81, 0xff,  // 137 (0X89): large empty square
   0x28, 0x7c, 0xaa, 0xaa, 0xaa, 0x00,  // 138 (0x8a): euro symbol
};

#define LASTCHAR ((sizeof(font)/6)+31)


// --- direct pin manipulation ------------------------------------------------

inline void xon0()   { PORTC |= B00001000; };
inline void xon1()   { PORTC |= B00000100; };
inline void xon2()   { PORTC |= B00000001; };
inline void xon3()   { PORTC |= B00000010; };
inline void xon4()   { PORTD |= B00100000; };
inline void xon5()   { PORTD |= B00010000; };
inline void xon6()   { PORTD |= B00001000; };
inline void xon7()   { PORTD |= B00000100; };
inline void xoff0()  { PORTC &= B11110111; };
inline void xoff1()  { PORTC &= B11111011; };
inline void xoff2()  { PORTC &= B11111110; };
inline void xoff3()  { PORTC &= B11111101; };
inline void xoff4()  { PORTD &= B11011111; };
inline void xoff5()  { PORTD &= B11101111; };
inline void xoff6()  { PORTD &= B11110111; };
inline void xoff7()  { PORTD &= B11111011; };

inline void xon()    { PORTD |= B00111100; PORTC |= B00001111; };
inline void xoff()   { PORTD &= B11000011; PORTC &= B11110000; };

inline void yon0()   { PORTB |= B00100000; };
inline void yon1()   { PORTB |= B00010000; };
inline void yon2()   { PORTB |= B00001000; };
inline void yon3()   { PORTB |= B00000100; };
inline void yon4()   { PORTB |= B00000010; };
inline void yon5()   { PORTB |= B00000001; };
inline void yon6()   { PORTD |= B10000000; };
inline void yon7()   { PORTD |= B01000000; };
inline void yoff0()  { PORTB &= B11011111; };
inline void yoff1()  { PORTB &= B11101111; };
inline void yoff2()  { PORTB &= B11110111; };
inline void yoff3()  { PORTB &= B11111011; };
inline void yoff4()  { PORTB &= B11111101; };
inline void yoff5()  { PORTB &= B11111110; };
inline void yoff6()  { PORTD &= B01111111; };
inline void yoff7()  { PORTD &= B10111111; };

inline void yoff()   { PORTB &= B11000000; PORTD &= B00111111; };
inline void yon()    { PORTB |= B00111111; PORTD |= B11000000; };


inline void column(unsigned char valore)
{
  register int v = valore;
  xon();
  if(reverse)
  {
    if(v&1)   xoff7();
    if(v&2)   xoff6();
    if(v&4)   xoff5();
    if(v&8)   xoff4();
    if(v&16)  xoff3();
    if(v&32)  xoff2();
    if(v&64)  xoff1();
    if(v&128) xoff0();
  }
  else
  {
    if(v&1)   xoff0();
    if(v&2)   xoff1();
    if(v&4)   xoff2();
    if(v&8)   xoff3();
    if(v&16)  xoff4();
    if(v&32)  xoff5();
    if(v&64)  xoff6();
    if(v&128) xoff7();
  }
}


// --- main -------------------------------------------------------------------

unsigned char* p, buffer[512];
const unsigned nmax = sizeof(buffer)-5;
unsigned z = 0;

void setup()
{
  DDRD |= B11111100;
  DDRB |= B00111111;
  DDRC |= B00001111;

  Serial.begin(9600);
  delay(100);
  Serial.println("!--ledmatrix");

  p = buffer;
  *p++ = ' ';
  *p++ = ' ';
  *p++ = 'O';
  *p++ = 'K';
  
#ifdef DEBUG  
  *p++ = ' '; for(unsigned e='!'; e<=LASTCHAR; e++) *p++=e;
#endif

  *p++ = ' ';
  *p++ = ' ';
  *p = 0;
  p = buffer;  
}


void loop()
{
  unsigned c, i, n, q;
  for(;;)
  {
    if(Serial.available())
    {
      for(q=1, n=2, p=buffer+2; q;)
      {
        c=Serial.read();
        switch(c)
        {
          case 0xc3:   // unicode
            switch(Serial.read())
            {
              case 0xa7: while(Serial.available()) Serial.read();
                         setup();
                         return; // reboot se uno dei caratteri era "ç"
              
              case 0xa0: c = 0x80; break; // à
              case 0xa8: c = 0x81; break; // è
              case 0xa9: c = 0x82; break; // é
              case 0xac: c = 0x83; break; // ì
              case 0xb2: c = 0x84; break; // ò
              case 0xb9: c = 0x85; break; // ù

              case 0xb8: c = 0x8a; break; // € from the character ø (altgr-o in ubuntu mapping)

              // comandi:

              case 0xb6: reverse = true;  // ë: reverse scrolling 
                         continue;

              case 0xab: reverse = false; // ö: normal scrolling
                         continue;

              default:   c = '?';
            }  // then, cascading:

          case 32 ... LASTCHAR :
            *p++ = c;
            n++;
#ifdef DEBUG            
            if(c<127) Serial.print((char)c);
            else { Serial.print("["); Serial.print(c); Serial.print("]"); }
#endif
            if(n >= nmax) q = 0;
            break;

          case '\n':
            q = 0;
#ifdef DEBUG
            Serial.print("-->");
#endif
            break;

          default: break;
        }
      }
      Serial.println("OK");
      *p++ = ' ';
      *p = 0;
      p = buffer;
      z = 0;
      xon();
      yon();
    }

     
    for(i=REP; i; i--)
    {
      register unsigned o = z;
      register unsigned char* v = p;

#define col()    column(pgm_read_byte(font + 6*(*v-' ') + o)) // using "v" and "o" variables
#define spara(k) col(); yon##k(); delayMicroseconds(PAU); if(++o==6) { o=0; v++; } yoff##k()

      if(reverse)
      {
        spara(7);
        spara(6);
        spara(5);
        spara(4);
        spara(3);
        spara(2);
        spara(1);
        spara(0);
      }
      else
      {
        spara(0);
        spara(1);
        spara(2);
        spara(3);
        spara(4);
        spara(5);
        spara(6);
        spara(7);
      }
    }

    if(++z >= 6)
    {
      z = 0;
      p++;
      if(p[2]=='\0')
      {
        p = buffer;
      }
    }
  }
}

// ---
